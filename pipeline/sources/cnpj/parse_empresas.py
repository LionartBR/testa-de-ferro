# pipeline/sources/cnpj/parse_empresas.py
#
# Parse Receita Federal empresas CSV into a typed staging DataFrame.
#
# Design decisions:
#   - The Receita Federal CNPJ file uses semicolons as separators and
#     Latin-1 encoding (ISO-8859-1). Polars is instructed explicitly.
#   - CNPJ_BASICO (8 digits) + CNPJ_ORDEM (4 digits) + CNPJ_DV (2 digits)
#     are concatenated and formatted as XX.XXX.XXX/XXXX-XX before storage.
#   - SITUACAO_CADASTRAL is a numeric code mapped to a human-readable string.
#     Unknown codes are mapped to "DESCONHECIDA" so no row is silently lost.
#   - DATA_INICIO_ATIVIDADE arrives as YYYYMMDD integer string and is parsed
#     to a Polars Date type. Invalid dates become null (not a crash).
#   - CAPITAL_SOCIAL uses a comma decimal separator in some Receita files, so
#     commas are replaced with dots before casting to Float64.
#   - pk_fornecedor is an auto-increment generated by row index.
#   - All column construction uses Polars Series/expressions instead of Python
#     lists (.to_list()) to avoid duplicating data in RAM (~2 GB savings on
#     the full Receita dataset).
#
# Invariants:
#   - Output columns must match dim_fornecedor in schema.sql (minus computed
#     score/alert columns filled by the transform layer).
#   - All rows that survive validate_empresas are guaranteed non-null cnpj and
#     razao_social.
from __future__ import annotations

from pathlib import Path

import polars as pl

# Mapping from Receita Federal numeric situacao code to human-readable label.
_SITUACAO_MAP: dict[int, str] = {
    1: "NULA",
    2: "ATIVA",
    3: "SUSPENSA",
    4: "INAPTA",
    8: "BAIXADA",
}


def _map_situacao(value: str | None) -> str | None:
    """Map a raw situacao code string to its human-readable label."""
    if value is None:
        return None
    try:
        return _SITUACAO_MAP.get(int(value), "DESCONHECIDA")
    except ValueError:
        return "DESCONHECIDA"


def parse_empresas(raw_path: Path) -> pl.DataFrame:
    """Parse Receita Federal empresas CSV into a typed staging DataFrame.

    The function reads the semicolon-delimited file produced by Receita Federal,
    constructs the formatted CNPJ, maps situacao codes, and parses dates and
    capital social into typed columns. The pk_fornecedor column is set to the
    row index and must be re-keyed by the transform layer.

    Args:
        raw_path: Path to the raw Receita Federal CSV file (Latin-1 encoding).

    Returns:
        Polars DataFrame with columns matching dim_fornecedor staging schema.
    """
    raw = pl.read_csv(
        raw_path,
        separator=";",
        encoding="latin1",
        infer_schema_length=0,  # read everything as strings to avoid type errors
        null_values=["", "NULL"],
        truncate_ragged_lines=True,
    )

    # Normalise column names to uppercase and stripped.
    raw = raw.rename({col: col.strip().upper() for col in raw.columns})

    n = len(raw)

    def _safe_series(col: str) -> pl.Series:
        """Return a stripped Series or a null Series for a missing column."""
        if col in raw.columns:
            return raw[col].str.strip_chars()
        return pl.Series(col, [None] * n, dtype=pl.Utf8)

    # Build formatted CNPJ via Polars vectorized ops (no .to_list()).
    basico = _safe_series("CNPJ_BASICO").fill_null("00000000").str.zfill(8)
    ordem = _safe_series("CNPJ_ORDEM").fill_null("0000").str.zfill(4)
    dv = _safe_series("CNPJ_DV").fill_null("00").str.zfill(2)

    _cnpj_tmp = pl.DataFrame({"_b": basico, "_o": ordem, "_d": dv})
    cnpj_series = _cnpj_tmp.select(
        pl.concat_str(
            [
                pl.col("_b").str.slice(0, 2),
                pl.lit("."),
                pl.col("_b").str.slice(2, 3),
                pl.lit("."),
                pl.col("_b").str.slice(5, 3),
                pl.lit("/"),
                pl.col("_o"),
                pl.lit("-"),
                pl.col("_d"),
            ]
        ).alias("cnpj")
    )["cnpj"]

    # Map numeric situacao codes to human-readable labels via replace_strict.
    if "SITUACAO_CADASTRAL" in raw.columns:
        situacao_series = (
            raw["SITUACAO_CADASTRAL"]
            .str.strip_chars()
            .cast(pl.Int64, strict=False)
            .replace_strict(_SITUACAO_MAP, default="DESCONHECIDA", return_dtype=pl.Utf8)
        )
    else:
        situacao_series = pl.Series("situacao", [None] * n, dtype=pl.Utf8)

    # Parse capital social: comma -> dot, then cast to Float64.
    if "CAPITAL_SOCIAL" in raw.columns:
        capital_series = raw["CAPITAL_SOCIAL"].str.strip_chars().str.replace(",", ".").cast(pl.Float64, strict=False)
    else:
        capital_series = pl.Series("capital_social", [None] * n, dtype=pl.Float64)

    # Parse data_inicio_atividade from YYYYMMDD string to date.
    data_series: pl.Series
    if "DATA_INICIO_ATIVIDADE" in raw.columns:
        data_series = raw["DATA_INICIO_ATIVIDADE"].str.strip_chars().str.to_date(format="%Y%m%d", strict=False)
    else:
        data_series = pl.Series("data_abertura", [None] * n, dtype=pl.Date)

    return pl.DataFrame(
        {
            "pk_fornecedor": list(range(1, n + 1)),
            "cnpj": cnpj_series,
            "razao_social": _safe_series("RAZAO_SOCIAL"),
            "data_abertura": data_series,
            "capital_social": capital_series,
            "cnae_principal": _safe_series("CNAE_FISCAL"),
            "cnae_descricao": pl.Series("cnae_descricao", [None] * n, dtype=pl.Utf8),
            "logradouro": pl.Series("logradouro", [None] * n, dtype=pl.Utf8),
            "municipio": pl.Series("municipio", [None] * n, dtype=pl.Utf8),
            "uf": pl.Series("uf", [None] * n, dtype=pl.Utf8),
            "cep": pl.Series("cep", [None] * n, dtype=pl.Utf8),
            "situacao": situacao_series,
        }
    )
