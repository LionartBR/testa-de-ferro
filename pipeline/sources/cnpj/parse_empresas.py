# pipeline/sources/cnpj/parse_empresas.py
#
# Parse Receita Federal empresas CSV into a typed staging DataFrame.
#
# Design decisions:
#   - The Receita Federal CNPJ file uses semicolons as separators and
#     Latin-1 encoding (ISO-8859-1). Polars is instructed explicitly.
#   - CNPJ_BASICO (8 digits) + CNPJ_ORDEM (4 digits) + CNPJ_DV (2 digits)
#     are concatenated and formatted as XX.XXX.XXX/XXXX-XX before storage.
#   - SITUACAO_CADASTRAL is a numeric code mapped to a human-readable string.
#     Unknown codes are mapped to "DESCONHECIDA" so no row is silently lost.
#   - DATA_INICIO_ATIVIDADE arrives as YYYYMMDD integer string and is parsed
#     to a Polars Date type. Invalid dates become null (not a crash).
#   - CAPITAL_SOCIAL uses a comma decimal separator in some Receita files, so
#     commas are replaced with dots before casting to Float64.
#   - pk_fornecedor is an auto-increment generated by row index.
#
# Invariants:
#   - Output columns must match dim_fornecedor in schema.sql (minus computed
#     score/alert columns filled by the transform layer).
#   - All rows that survive validate_empresas are guaranteed non-null cnpj and
#     razao_social.
from __future__ import annotations

from pathlib import Path

import polars as pl

# Mapping from Receita Federal numeric situacao code to human-readable label.
_SITUACAO_MAP: dict[int, str] = {
    1: "NULA",
    2: "ATIVA",
    3: "SUSPENSA",
    4: "INAPTA",
    8: "BAIXADA",
}


def _map_situacao(value: str | None) -> str | None:
    """Map a raw situacao code string to its human-readable label."""
    if value is None:
        return None
    try:
        return _SITUACAO_MAP.get(int(value), "DESCONHECIDA")
    except ValueError:
        return "DESCONHECIDA"


def parse_empresas(raw_path: Path) -> pl.DataFrame:
    """Parse Receita Federal empresas CSV into a typed staging DataFrame.

    The function reads the semicolon-delimited file produced by Receita Federal,
    constructs the formatted CNPJ, maps situacao codes, and parses dates and
    capital social into typed columns. The pk_fornecedor column is set to the
    row index and must be re-keyed by the transform layer.

    Args:
        raw_path: Path to the raw Receita Federal CSV file (Latin-1 encoding).

    Returns:
        Polars DataFrame with columns matching dim_fornecedor staging schema.
    """
    raw = pl.read_csv(
        raw_path,
        separator=";",
        encoding="latin1",
        infer_schema_length=0,  # read everything as strings to avoid type errors
        null_values=["", "NULL"],
        truncate_ragged_lines=True,
    )

    # Normalise column names to uppercase and stripped.
    raw = raw.rename({col: col.strip().upper() for col in raw.columns})

    n = len(raw)

    def _safe_str(col: str) -> list[str | None]:
        """Return a list of stripped strings or Nones for a column."""
        if col not in raw.columns:
            return [None] * n
        return raw[col].str.strip_chars().to_list()

    # Build formatted CNPJ: zero-pad each part then join with punctuation.
    basico_list = [
        v.strip().zfill(8) if v else "00000000"
        for v in (raw["CNPJ_BASICO"].to_list() if "CNPJ_BASICO" in raw.columns else [""] * n)
    ]
    ordem_list = [
        v.strip().zfill(4) if v else "0000"
        for v in (raw["CNPJ_ORDEM"].to_list() if "CNPJ_ORDEM" in raw.columns else [""] * n)
    ]
    dv_list = [
        v.strip().zfill(2) if v else "00" for v in (raw["CNPJ_DV"].to_list() if "CNPJ_DV" in raw.columns else [""] * n)
    ]

    cnpj_list = [
        f"{b[:2]}.{b[2:5]}.{b[5:8]}/{o}-{d}" for b, o, d in zip(basico_list, ordem_list, dv_list, strict=False)
    ]

    # Map numeric situacao codes to human-readable labels.
    if "SITUACAO_CADASTRAL" in raw.columns:
        situacao_list: list[str | None] = [_map_situacao(v) for v in raw["SITUACAO_CADASTRAL"].to_list()]
    else:
        situacao_list = [None] * n

    # Parse capital social: comma -> dot, then cast to float.
    if "CAPITAL_SOCIAL" in raw.columns:
        capital_list: list[float | None] = []
        for v in raw["CAPITAL_SOCIAL"].to_list():
            if v is None:
                capital_list.append(None)
            else:
                try:
                    capital_list.append(float(str(v).replace(",", ".")))
                except ValueError:
                    capital_list.append(None)
    else:
        capital_list = [None] * n

    # Parse data_inicio_atividade from YYYYMMDD string to date.
    data_series: pl.Series
    if "DATA_INICIO_ATIVIDADE" in raw.columns:
        data_series = raw["DATA_INICIO_ATIVIDADE"].str.strip_chars().str.to_date(format="%Y%m%d", strict=False)
    else:
        data_series = pl.Series("data_abertura", [None] * n, dtype=pl.Date)

    razao_list = _safe_str("RAZAO_SOCIAL")
    cnae_list = _safe_str("CNAE_FISCAL")

    return pl.DataFrame(
        {
            "pk_fornecedor": list(range(1, n + 1)),
            "cnpj": cnpj_list,
            "razao_social": razao_list,
            "data_abertura": data_series.rename("data_abertura"),
            "capital_social": pl.Series("capital_social", capital_list, dtype=pl.Float64),
            "cnae_principal": cnae_list,
            "cnae_descricao": [None] * n,
            "logradouro": [None] * n,
            "municipio": [None] * n,
            "uf": [None] * n,
            "cep": [None] * n,
            "situacao": situacao_list,
        }
    )
